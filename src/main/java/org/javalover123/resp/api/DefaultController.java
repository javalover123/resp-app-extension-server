/*
 * RESP.app Extension server
 * RESP.app Extension Server API allows you to extend RESP.app with your custom data formatters
 *
 * The version of the OpenAPI document: 2022.0-preview1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.javalover123.resp.api;

import io.micronaut.http.annotation.*;
import io.micronaut.core.annotation.Nullable;
import io.micronaut.core.convert.format.Format;
import io.micronaut.security.annotation.Secured;
import io.micronaut.security.rules.SecurityRule;
import org.javalover123.resp.service.BaseRespFormatter;
import org.javalover123.resp.service.TimestampRespFormatter;
import org.javalover123.resp.util.JsonUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;
import io.micronaut.http.HttpStatus;
import io.micronaut.http.exceptions.HttpStatusException;
import org.javalover123.resp.model.DataFormatter;
import org.javalover123.resp.model.DataFormattersIdDecodePost400Response;
import org.javalover123.resp.model.DecodePayload;
import org.javalover123.resp.model.EncodePayload;
import javax.annotation.Generated;
import java.io.IOException;
import java.util.*;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;

@Generated(value="org.openapitools.codegen.languages.JavaMicronautServerCodegen", date="2022-07-30T22:32:13.307768900+08:00[Asia/Shanghai]")
@Controller
@Tag(name = "Default", description = "The Default API")
public class DefaultController {

    private Logger log = LoggerFactory.getLogger(this.getClass());

    private Map<DataFormatter, BaseRespFormatter> formatterMap = initFormatterMap();

    private Map<DataFormatter, BaseRespFormatter> initFormatterMap() {
        Map<DataFormatter, BaseRespFormatter> formatterMap = new LinkedHashMap<>();
        formatterMap.put(new DataFormatter("timestamp", "Timestamp"), new TimestampRespFormatter());
        return formatterMap;
    }

    /**
     * Returns a list of data formatters
     *
     * @return List&lt;DataFormatter&gt;
     */
    @Operation(
        operationId = "dataFormattersGet",
        responses = {
            @ApiResponse(responseCode = "200", description = "Successful response", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataFormatter.class))
            })
        },
        security = {
            @SecurityRequirement(name = "basic")
        }
    )
    @Get(uri="/data-formatters")
    @Produces(value = {"application/json"})
    @Secured({SecurityRule.IS_AUTHENTICATED})
    public Mono<List<DataFormatter>> dataFormattersGet() {
        List<DataFormatter> list = new ArrayList<>(formatterMap.keySet());
        return Mono.just(list);
    }


    /**
     * dataFormattersIdDecodePost
     *
     * @param id The id of data formatter (required)
     * @param decodePayload  (optional)
     * @return String
     */
    @Operation(
        operationId = "dataFormattersIdDecodePost",
        responses = {
            @ApiResponse(responseCode = "200", description = "Successful response with correct content type. RESP.app supports text/plain, application/json and application/octet-stream", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            }),
            @ApiResponse(responseCode = "400", description = "Validation error response", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataFormattersIdDecodePost400Response.class))
            })
        },
        parameters = {
            @Parameter(name = "id", description = "The id of data formatter", required = true),
            @Parameter(name = "decodePayload")
        },
        security = {
            @SecurityRequirement(name = "basic")
        }
    )
    @Post(uri="/data-formatters/{id}/decode")
    @Produces(value = {"application/json"})
    @Consumes(value = {"application/json"})
    @Secured({SecurityRule.IS_AUTHENTICATED})
    public Mono<String> dataFormattersIdDecodePost(
        @PathVariable(value="id") @NotNull String id, 
        @Body @Nullable @Valid DecodePayload decodePayload
    ) {
        try {
            BaseRespFormatter formatter = fetchFormatter(id);
            return Mono.just(formatter.decode(decodePayload));
        } catch (Exception e) {
            log.error(id + "|decode error|" + decodePayload, e);
            return error(e.getMessage());
        }
    }


    /**
     * dataFormattersIdEncodePost
     *
     * @param id The id of data formatter (required)
     * @param encodePayload  (optional)
     * @return String
     */
    @Operation(
        operationId = "dataFormattersIdEncodePost",
        responses = {
            @ApiResponse(responseCode = "200", description = "Successful response with content type application/octet-stream", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            }),
            @ApiResponse(responseCode = "400", description = "Validation error response", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataFormattersIdDecodePost400Response.class))
            })
        },
        parameters = {
            @Parameter(name = "id", description = "The id of data formatter", required = true),
            @Parameter(name = "encodePayload")
        },
        security = {
            @SecurityRequirement(name = "basic")
        }
    )
    @Post(uri="/data-formatters/{id}/encode")
    @Produces(value = {"application/json"})
    @Consumes(value = {"application/json"})
    @Secured({SecurityRule.IS_AUTHENTICATED})
    public Mono<String> dataFormattersIdEncodePost(
        @PathVariable(value="id") @NotNull String id, 
        @Body @Nullable @Valid EncodePayload encodePayload
    ) {
        return error("Unsupport encode");
    }


    private Mono<String> error(String msg) {
        DataFormattersIdDecodePost400Response response = new DataFormattersIdDecodePost400Response().error(msg);
        return Mono.error(new HttpStatusException(HttpStatus.BAD_REQUEST, JsonUtil.toJson(response)));
    }

    private BaseRespFormatter fetchFormatter(String id) {
        for (Map.Entry<DataFormatter, BaseRespFormatter> entry : formatterMap.entrySet()) {
            if (entry.getKey().getId().equals(id)) {
                return entry.getValue();
            }
        }
        throw new UnsupportedOperationException("Unsupport id," + id);
    }

}
